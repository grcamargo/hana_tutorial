'use strict';

//Include
const NotFoundError = require('./../utils/errors/http/notFound');
const SqlError = require('../utils/errors/sqlError');

const CreateSqlErrorLog = (context, err, sql, parameters) => {
    if (!err) {
        return;
    }

    context.logger.info('SQL Exec', 'Error: \n' + JSON.stringify(err));
    context.logger.info('SQL Exec', 'SQL: \n' + sql);

    if (parameters) {
        // force parameter logging
        context.logger.logSqlParameters( parameters);
    }
    return new SqlError(context, err);
};

const executeSqlAsPreparedStatement = (context, sql, parameters, rowCb) => {
    const client = context.db.client;

    let startTime = 0;

    context.logger.logSqlCommand(sql);

    startTime = context.logger.getStartTimeSql();

    client.prepare(sql, (errPrep, statement) => {
        context.logger.logSqlTime('prepare', startTime, sql);

        if (errPrep) {
            return rowCb(CreateSqlErrorLog(context, errPrep, sql, startTime)); // does logging
        }

        context.logger.logSqlParameters( parameters);

        startTime = context.logger.getStartTimeSql();
        statement.exec(parameters, (errExec, rows) => {
            context.logger.logSqlTime('exec', startTime, sql);

            // try dropping the statement always
            startTime = context.logger.getStartTimeSql();
            statement.drop((errDrop) => {
                context.logger.logSqlTime('drop', startTime, sql);
                if (errDrop) {
                    // don't hide any execution error, just log
                    context.logger.debug('Could not drop proc statement:', errDrop.message);
                }

                if (errExec) {
                    return rowCb(CreateSqlErrorLog(context, errExec));
                }
                if (rows) {
                    context.logger.logSqlData(rows);
                }

                return rowCb(null, rows);
            });
        });
    });
};

const executeSqlAsPreparedStatementNoResult = (context, sql, parameters, cb) => {
    executeSqlAsPreparedStatement(context, sql, parameters, (err) => {
        return cb(err);
    });
};

const executeSqlDirectly = (context, sql, cb) => {
    const client = context.db.client;

    context.logger.logSqlCommand(sql);

    let startTime = context.logger.getStartTimeSql();
    client.exec(sql, (errExec, rows) => {
        context.logger.logSqlTime('exec', startTime, sql);
        return cb(CreateSqlErrorLog(context, errExec), rows);
    });
};

const executeSqlDirectlyNoResult = (context, sql, cb) => {
    executeSqlDirectly(context, sql, (err) => {
        return cb(err);
    });
};

exports.resultSetCheckRowCountForUpdate = function (context, resultSet, index, expectedAffectedRows, asyncDone) {
    if (!resultSet || !Array.isArray(resultSet)) {
        return asyncDone(new NotFoundError("Empty resultset"), context);
    }

    if (index >= resultSet.length) {
        return asyncDone(new NotFoundError("Wrong resultset count"), context);
    }

    const affectedRows = resultSet[index];


    if (affectedRows !== expectedAffectedRows) {
        return asyncDone(new NotFoundError("Could not modify resource. Resource does not exist"), context);
    }
    return asyncDone(null, context);
};

module.exports.executeSqlDirectly = executeSqlDirectly;
module.exports.executeSqlDirectlyNoResult = executeSqlDirectlyNoResult;
module.exports.executeSqlAsPreparedStatement = executeSqlAsPreparedStatement;
module.exports.executeSqlAsPreparedStatementNoResult = executeSqlAsPreparedStatementNoResult;

